description: |
  - Auto-tagging from dev branch
  - Semantic versioning
  - Ensure Release
  - Docker reproducible build
  - Security scan
  - Manual approval
  - Reporting

inputs:
  scope:
    description: "Java Spring Boot independent application"
    required: true
  service:
    description: "A Service belong to Scope"
    required: true
  image:
    description: "Docker Image repository name"
    required: true
  version:
    description: "Target semantic version"
    required: true
  key:
    required: true
    description: "SSH Deploy Key granting write access in this repository."
  pat:
    required: true
    description: "GitHub Personal Access Token (PAT) used for authentication with GitHub CLI when creating Pull Requests."

runs:
  using: composite
  steps:
    # ==========================================================
    # üåø STEP 1: Ensure release branch exists & sync from dev
    # If release/<image> branch doesn't exist, create from dev.
    # If exists, sync latest commits from origin/dev into it.
    # ==========================================================
    - name: üåø Ensure & Sync Release Branch
      id: branch
      shell: bash
      run: |
        set -e
        RELEASE_BRANCH="release/${{ inputs.image }}"
        echo "üîç Checking branch: $RELEASE_BRANCH"
        git fetch origin dev --quiet
        git fetch origin "$RELEASE_BRANCH" --quiet || true
        if git rev-parse --verify "origin/$RELEASE_BRANCH" >/dev/null 2>&1; then
          echo "‚úÖ Found existing branch: $RELEASE_BRANCH"
          git checkout -B "$RELEASE_BRANCH" "origin/$RELEASE_BRANCH"
          echo "üîÑ Merging latest dev changes into $RELEASE_BRANCH..."
          git merge --no-edit origin/dev || true
          if [[ -n "$(git status --porcelain)" ]]; then
            echo "üì¶ Push updated $RELEASE_BRANCH after sync"
            mkdir -p ~/.ssh
            echo "${{ inputs.key }}" > ~/.ssh/id_rsa
            chmod 600 ~/.ssh/id_rsa
            ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts 2>/dev/null
            git config user.name "release[bot]"
            git config user.email "release[bot]@users.noreply.github.com"
            git push origin "$RELEASE_BRANCH"
          else
            echo "‚úÖ Release branch already up to date with dev."
          fi
        else
          echo "üÜï Creating new branch: $RELEASE_BRANCH from origin/dev"
          git checkout -b "$RELEASE_BRANCH" origin/dev
          git push origin "$RELEASE_BRANCH"
        fi
        echo "branch=$RELEASE_BRANCH" >> $GITHUB_OUTPUT

    # ==========================================================
    # üè∑Ô∏è STEP 2: Auto-create Git Tag
    # Automatically creates and pushes a semantic version tag to remote.
    # Used for scheduled or manual releases without human intervention.
    # ==========================================================
    - name: üè∑Ô∏è Create Git Tag
      id: tag
      shell: bash
      run: |
        TAG="${{ inputs.version }}"
        BRANCH="${{ steps.branch.outputs.branch }}"
        mkdir -p .release-log
        LOG=".release-log/tag-create.log"
        echo "üîç Checking if tag '$TAG' exists..." | tee -a "$LOG"
        git fetch origin --tags --quiet
        if git rev-parse "$TAG" >/dev/null 2>&1; then
          echo "‚ùå Tag already exists: $TAG" | tee -a "$LOG"
          echo "exists=true" >> $GITHUB_OUTPUT
          exit 0
        fi
        echo "üîë Configuring SSH Deploy Key..."
        mkdir -p ~/.ssh
        echo "${{ inputs.key }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts 2>/dev/null
        git config user.name "release[bot]"
        git config user.email "release[bot]@users.noreply.github.com"
        git checkout "$BRANCH"
        git tag -a "$TAG" -m "Automated release $TAG for ${{ inputs.image }}"
        git push git@github.com:${{ github.repository }} "$TAG"
        echo "‚úÖ Created and pushed tag: $TAG on $BRANCH" | tee -a "$LOG"
        echo "exists=false" >> $GITHUB_OUTPUT

    # ==========================================================
    # üê≥ STEP 3: Build Docker image
    # Builds the Docker image for the target service with caching enabled.
    # Produces a deterministic tag: ghcr.io/<owner>/<image>:<version>.
    # ==========================================================
    - name: üèóÔ∏è Build Docker Image
      if: success()
      shell: bash
      run: |
        IMAGE="ghcr.io/${{ github.repository_owner }}/${{ inputs.image }}:${{ inputs.version }}"
        docker build \
          --cache-from="$IMAGE" \
          -t "$IMAGE" \
          -f .docker/Dockerfile \
          --build-arg SCOPE="${{ inputs.scope }}" \
          --build-arg SERVICE="${{ inputs.service }}" \
          .
        echo "IMAGE=$IMAGE" >> $GITHUB_ENV

    # ==========================================================
    # üß¨ STEP 4: Verify reproducible build
    # Rebuilds the same Docker image twice and compares their SHA IDs.
    # Ensures build reproducibility and consistency across environments.
    # ==========================================================
    - name: üß™ Verify Reproducibility
      if: success()
      shell: bash
      run: |
        HASH1=$(docker inspect --format='{{.Id}}' "$IMAGE")
        docker build \
          -t "$IMAGE-test" \
          -f .docker/Dockerfile \
          --build-arg SCOPE="${{ inputs.scope }}" \
          --build-arg SERVICE="${{ inputs.service }}" \
          .
        HASH2=$(docker inspect --format='{{.Id}}' "$IMAGE-test")
        if [[ "$HASH1" != "$HASH2" ]]; then
          echo "‚ùå Non-deterministic build detected!"
          exit 1
        fi
        echo "‚úÖ Reproducible build confirmed"

    # ==========================================================
    # üß∞ STEP 5: Initialize CodeQL (SAST)
    # Sets up GitHub CodeQL for static application security testing.
    # ==========================================================
    - name: üß∞ Initialize CodeQL
      if: success()
      uses: github/codeql-action/init@v3
      with:
        languages: java

    # ==========================================================
    # üß™ STEP 6: Run CodeQL analysis
    # Executes static analysis to identify vulnerabilities in source code.
    # ==========================================================
    - name: üî¨ Analyze with CodeQL
      if: success()
      uses: github/codeql-action/analyze@v3

    # ==========================================================
    # üõ°Ô∏è STEP 7: Container vulnerability scan
    # Scans the built Docker image using Trivy to detect OS and library issues.
    # The pipeline fails on HIGH or CRITICAL findings.
    # ==========================================================
    - name: üõ°Ô∏è Scan Docker Image (Trivy)
      if: success()
      uses: aquasecurity/trivy-action@0.20.0
      with:
        image-ref: ${{ env.IMAGE }}
        severity: HIGH,CRITICAL
        ignore-unfixed: true
        exit-code: 1

    # ==========================================================
    # üìä STEP 8: Upload release log artifacts
    # Publishes the release logs and tagging info as a downloadable artifact
    # for manual review and audit tracking.
    # ==========================================================
    - name: üì§ Upload Release Report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: release-report-${{ inputs.image }}-${{ inputs.version }}
        path: .release-log/

    # ==========================================================
    # üîÑ STEP 9: Create Pull Request to main
    # Automatically opens or updates a PR from release/<image> to main.
    # Includes context-aware title, body, and reviewer assignment.
    # Used for integrating verified releases into mainline.
    # ==========================================================
    - name: üîÑ Create Pull Request to main
      if: success()
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.pat }}
      run: |
        RELEASE_BRANCH="${{ steps.branch.outputs.branch }}"
        TITLE="üöÄ Merge ${RELEASE_BRANCH} ‚Üí main"
        BODY=$(cat <<EOF
        ### üîÑ Automated Release PR
        This pull request was automatically created after successful:
          - ‚úÖ Sync from \`dev\`
          - ‚úÖ Tag \`${{ inputs.version }}\`
          - ‚úÖ Build & Reproducibility Check
          - ‚úÖ CodeQL (SAST)
          - ‚úÖ Trivy (Container Security Scan)

          #### üì¶ Service Details
          - **Scope:** \`${{ inputs.scope }}\`
          - **Service:** \`${{ inputs.service }}\`
          - **Image:** \`${{ inputs.image }}\`
          - **Version:** \`${{ inputs.version }}\`
        > Created by the \`release[bot]\` automation workflow for controlled promotion to \`main\`.
        EOF
        )
        gh pr create \
          --title "$TITLE" \
          --body "$BODY"
          --base main \
          --head "$RELEASE_BRANCH" || echo "‚ÑπÔ∏è Pull Request already exists."
