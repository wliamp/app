name: CD Deploy

on:
  workflow_dispatch:
    inputs:
      repo:
        description: "Docker Image repo name"
        required: true
      ver:
        description: "Docker image version"
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/cd-deploy
        with:
          image_repo: ${{ github.event.inputs.repo }}
          image_ver: ${{ github.event.inputs.ver }}
          manifests: ${{ vars.K8S_MANIFESTS_BASE }}/${{ github.event.inputs.repo }}

          image_space: ${{ vars.DOCKERHUB_REPO }}
          approvers: ${{ vars.APPROVERS }}
          staging_cluster: ${{ vars.K8S_STAGING_CLUSTER }}
          prod_cluster: ${{ vars.K8S_PROD_CLUSTER }}
          staging_namespace: ${{ vars.K8S_STAGING_NAMESPACE }}
          prod_namespace: ${{ vars.K8S_PROD_NAMESPACE }}
          prom: ${{ vars.PROM_PUSH_URL }}
          slack: ${{ vars.SLACK_WEBHOOK_URL }}
          grafana: ${{ vars.GRAFANA_URL }}

          k8s_config: ${{ secrets.K8S_CONFIG_BASE64 }}
          grafana_key: ${{ secrets.GRAFANA_API_KEY }}


name: "CD Deploy"
description: |
  - Load kubeconfig from secret
  - Deploy to Staging (namespace configurable)
  - Health & Smoke Tests (configurable endpoint)
  - Manual Approval Gate (timeout)
  - Production Rollout (namespace configurable)
  - Observability & Reporting (Prometheus/Grafana/Slack safe checks)

inputs:
  image_space:
    description: "Docker Image namespace"
    required: true
  image_repo:
    description: "Docker Image repo name"
    required: true
  image_ver:
    description: "Docker Image version"
    required: true
  staging_cluster:
    description: "Kubernetes context for staging cluster"
    required: true
  prod_cluster:
    description: "Kubernetes context for production cluster"
    required: true
  staging_namespace:
    description: "Kubernetes namespace for staging"
    required: false
    default: "staging"
  prod_namespace:
    description: "Kubernetes namespace for production"
    required: false
    default: "production"
  health_endpoint:
    description: "Health check path (on the service)"
    required: false
    default: "/health"
  approvers:
    description: "Comma-separated list of GitHub usernames allowed to approve"
    required: true
  manifests:
    description: "Path to Kubernetes manifests or Helm chart folder"
    required: true
  approval_timeout_minutes:
    description: "Timeout for manual approval step (minutes)"
    required: false
    default: "60"
  k8s_config:
    description: "Base64-encoded kubeconfig content used to authenticate kubectl commands"
    required: true
  prom:
    description: "Prometheus Push gateway endpoint URL for deployment metrics"
    required: false
  slack:
    description: "Slack webhook URL for deployment alerts and notifications"
    required: false
  grafana:
    description: "Grafana API base URL for creating deployment annotations"
    required: false
  grafana_key:
    description: "Grafana API key with permission to post annotations"
    required: false

runs:
  using: composite
  steps:
    - name: ‚öôÔ∏è Ensure environment
      shell: bash
      run: |
        set -euo pipefail
        echo "Inputs summary: image=${{ inputs.image_repo }}, version=${{ inputs.image_ver }}"
        echo "staging: ctx=${{ inputs.staging_cluster }}, ns=${{ inputs.staging_namespace }}"
        echo "prod: ctx=${{ inputs.prod_cluster }}, ns=${{ inputs.prod_namespace }}"

    - name: üîê Load kubeconfig (from secret)
      shell: bash
      env:
        KUBECONFIG_BASE64: ${{ inputs.k8s_config }}
      run: |
        set -euo pipefail
        if [ -z "${KUBECONFIG_BASE64:-}" ]; then
          echo "‚ùå KUBECONFIG_BASE64 secret is not set. Aborting."
          exit 1
        fi
        mkdir -p "$HOME/.kube"
        echo "$KUBECONFIG_BASE64" | base64 -d > "$HOME/.kube/config"
        chmod 600 "$HOME/.kube/config"
        echo "‚úÖ kubeconfig loaded"

    - name: üß© Staging deployment
      shell: bash
      run: |
        set -euo pipefail
        FULL_IMAGE="docker.io/${{ inputs.image_space }}/${{ inputs.image_repo }}:${{ inputs.image_ver }}"
        echo "üöÄ Deploying '${FULL_IMAGE}' to staging context '${{ inputs.staging_cluster }}' namespace '${{ inputs.staging_namespace }}'"

        kubectl config use-context "${{ inputs.staging_cluster }}"
        kubectl get namespace "${{ inputs.staging_namespace }}" >/dev/null 2>&1 || kubectl create namespace "${{ inputs.staging_namespace }}"

        kubectl apply -f "${{ inputs.manifests }}" -n "${{ inputs.staging_namespace }}"

        kubectl rollout status deploy/${{ inputs.image_repo }} -n "${{ inputs.staging_namespace }}" --timeout=300s
        echo "‚úÖ Staging rollout finished"

    - name: üß™ Health & Smoke Tests
      shell: bash
      run: |
        set -eo pipefail
        echo "Running health check for image=${{ inputs.image_repo }} endpoint=${{ inputs.health_endpoint }}"

        SERVICE_HOST="${{ inputs.image_repo }}"
        SERVICE_PORT=${{ env.SERVICE_PORT:-8080 }}
        ENDPOINT="${{ inputs.health_endpoint }}"

        # Run the curl pod to test service reachability inside cluster
        kubectl run --rm -i "${{ inputs.image_repo }}-smoke" --image=curlimages/curl -n "${{ inputs.staging_namespace }}" --restart=Never --command -- sh -c \
          "curl -sf http://${SERVICE_HOST}:$SERVICE_PORT$ENDPOINT || exit 1"

        echo "‚úÖ Staging health OK"
      env:
        SERVICE_PORT: 8080

    - name: ‚è∏Ô∏è Manual Approval (Production)
      uses: trstringer/manual-approval@v1
      with:
        secret: ${{ github.token }}
        approvers: ${{ inputs.approvers }}
        minimum-approvals: 1
        issue-title: Approve Production Rollout for ${{ inputs.image_repo }}
        issue-body: |
          ‚úÖ Staging passed for ${{ inputs.image_repo }}
          üîñ Image: ${{ inputs.image_repo }}:${{ inputs.image_ver }}
          Please approve deployment to Production.
        timeout-minutes: ${{ inputs.approval_timeout_minutes }}

    - name: üß© Production rollout
      shell: bash
      run: |
        set -euo pipefail
        FULL_IMAGE="docker.io/${{ inputs.image_space }}/${{ inputs.image_repo }}:${{ inputs.image_ver }}"
        echo "üöÄ Rolling out '${FULL_IMAGE}' to production context '${{ inputs.prod_cluster }}' namespace '${{ inputs.prod_namespace }}'"

        kubectl config use-context "${{ inputs.prod_cluster }}"
        kubectl get namespace "${{ inputs.prod_namespace }}" >/dev/null 2>&1 || kubectl create namespace "${{ inputs.prod_namespace }}"

        kubectl apply -f "${{ inputs.manifests }}" -n "${{ inputs.prod_namespace }}"
        kubectl rollout status deploy/${{ inputs.image_repo }} -n "${{ inputs.prod_namespace }}" --timeout=600s
        echo "‚úÖ Production rollout completed"

    - name: üìä Observability & Alerts (safe)
      shell: bash
      env:
        PROM_PUSH_URL: ${{ inputs.prom }}
        SLACK_WEBHOOK_URL: ${{ inputs.slack }}
        GRAFANA_URL: ${{ inputs.grafana }}
        GRAFANA_API_KEY: ${{ inputs.grafana_key }}
      run: |
        set -euo pipefail
        echo "Collecting recent logs for ${{ inputs.image_repo }}"

        kubectl logs -l app=${{ inputs.image_repo }} -n "${{ inputs.prod_namespace }}" --tail=300 > deploy_logs.txt || true

        if grep -qE "ERROR|Exception|Fail|panic" deploy_logs.txt; then
          echo "‚ö†Ô∏è Errors detected in deployment logs"
          DEPLOY_STATUS=0
          ALERT_COLOR="#ff0000"
          ALERT_MSG="üö® *Deployment FAILED!* image *${{ inputs.image_repo }}* (version *${{ inputs.image_ver }}*) encountered errors."
        else
          echo "‚úÖ Logs look clean"
          DEPLOY_STATUS=1
          ALERT_COLOR="#36a64f"
          ALERT_MSG="‚úÖ *Deployment successful!* image *${{ inputs.image_repo }}* (version *${{ inputs.image_ver }}*) is healthy."
        fi

        if [ -n "${PROM_PUSH_URL:-}" ]; then
          echo "üìà Pushing deployment metrics to ${PROM_PUSH_URL}"
          cat <<EOF | curl --silent --show-error --data-binary @- "${PROM_PUSH_URL}/metrics/job/deployment/image/${{ inputs.image_repo }}"
        deployment_status ${DEPLOY_STATUS}
        deployment_timestamp $(date +%s)
        deployment_version_info{image="${{ inputs.image_repo }}",version="${{ inputs.image_ver }}"} 1
        EOF
        else
        echo "‚ö†Ô∏è PROM_PUSH_URL not configured - skipping metrics push"
        fi

        if [ -n "${GRAFANA_URL:-}" ] && [ -n "${GRAFANA_API_KEY:-}" ]; then
        echo "üß† Creating Grafana annotation"
        curl -s -X POST "${GRAFANA_URL}/api/annotations" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer ${GRAFANA_API_KEY}" \
        -d "$(jq -n --arg text "Deployment of ${{ inputs.image_repo }}:${{ inputs.image_ver }}" --arg tags "deployment,${{ inputs.image_repo }}" '{text: $text, tags: ($tags | split(","))}')" || echo "‚ö†Ô∏è Failed to push Grafana annotation"
          else
          echo "‚ö†Ô∏è Grafana not configured - skipping annotation"
          fi

          if [ -n "${SLACK_WEBHOOK_URL:-}" ]; then
          echo "üí¨ Sending Slack notification"
          curl -s -X POST "${SLACK_WEBHOOK_URL}" \
        -H "Content-Type: application/json" \
        -d "$(jq -n --arg text "${ALERT_MSG}" --arg color "${ALERT_COLOR}" '{attachments: [{color: $color, text: $text}]}')" || echo "‚ö†Ô∏è Failed to send Slack alert"
          else
          echo "‚ö†Ô∏è Slack webhook not configured - skipping alert"
          fi

    - name: üìã Summary & Reporting
      shell: bash
      run: |
        set -euo pipefail
        echo "Generating deployment summary"
        cat > report.txt <<EOF
        Image: ${{ inputs.image_repo }}:${{ inputs.image_ver }}
        Staging: context=${{ inputs.staging_cluster }} ns=${{ inputs.staging_namespace }}
        Production: context=${{ inputs.prod_cluster }} ns=${{ inputs.prod_namespace }}
        Timestamp: $(date -u)
          EOF
          echo "Upload artifact"

    - name: Artifact
      uses: actions/upload-artifact@v4
      with:
        name: cd-report-${{ inputs.image_repo }}
        path: report.txt
