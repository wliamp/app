description: |
  - Load kubeconfig from secret
  - Deploy to Staging (namespace configurable)
  - Health & Smoke Tests (configurable endpoint)
  - Manual Approval Gate (timeout)
  - Production Rollout (namespace configurable)
  - Observability & Reporting (Prometheus/Grafana/Slack safe checks)

inputs:
  image_space:
    required: true
    description: "Docker Hub (or registry) namespace where the image resides."
  image_repo:
    required: true
    description: "Repository name of the Docker image (service name)."
  image_ver:
    required: true
    description: "Docker image version tag to deploy (e.g., 'v1.0.0' or commit SHA)."
  staging_cluster:
    required: true
    description: "Kubernetes context name for the Staging environment."
  prod_cluster:
    required: true
    description: "Kubernetes context name for the Production environment."
  staging_namespace:
    required: false
    default: "staging"
    description: "Namespace to deploy the service in Staging (default: 'staging')."
  prod_namespace:
    required: false
    default: "production"
    description: "Namespace to deploy the service in Production (default: 'production')."
  health_endpoint:
    required: false
    default: "/health"
    description: "Path used for health check during Staging smoke test (default: '/health')."
  approvers:
    required: true
    description: "Comma-separated list of GitHub usernames authorized to approve Production rollout."
  manifests:
    required: true
    description: "Path to Kubernetes manifests or Helm chart directory for deployment."
  approval_timeout_minutes:
    required: false
    default: "60"
    description: "Maximum waiting time (in minutes) for manual approval before the job fails."
  k8s_config:
    required: true
    description: "Base64-encoded kubeconfig content to authenticate kubectl commands."
  prom:
    required: false
    description: "Prometheus Pushgateway endpoint for sending deployment metrics."
  slack:
    required: false
    description: "Slack Incoming Webhook URL for deployment notifications and alerts."
  grafana:
    required: false
    description: "Grafana API base URL for posting deployment annotations."
  grafana_key:
    required: false
    description: "Grafana API key with write permissions for annotations."

runs:
  using: composite
  steps:

    # ==========================================================
    # ‚öôÔ∏è STEP 1: Ensure environment
    # Prints out key deployment parameters for traceability,
    # verifies required input values, and provides context
    # on which image and clusters are being targeted.
    # ==========================================================
    - name: ‚öôÔ∏è Ensure environment
      shell: bash
      run: |
        set -euo pipefail
        echo "Inputs summary: image=${{ inputs.image_repo }}, version=${{ inputs.image_ver }}"
        echo "staging: ctx=${{ inputs.staging_cluster }}, ns=${{ inputs.staging_namespace }}"
        echo "prod: ctx=${{ inputs.prod_cluster }}, ns=${{ inputs.prod_namespace }}"

    # ==========================================================
    # üîê STEP 2: Load kubeconfig (from secret)
    # Decodes the base64-encoded kubeconfig secret and writes
    # it to ~/.kube/config, granting kubectl access to clusters.
    # Aborts immediately if the secret is missing.
    # ==========================================================
    - name: üîê Load kubeconfig (from secret)
      shell: bash
      env:
        KUBECONFIG_BASE64: ${{ inputs.k8s_config }}
      run: |
        set -euo pipefail
        if [ -z "${KUBECONFIG_BASE64:-}" ]; then
          echo "‚ùå KUBECONFIG_BASE64 secret is not set. Aborting."
          exit 1
        fi
        mkdir -p "$HOME/.kube"
        echo "$KUBECONFIG_BASE64" | base64 -d > "$HOME/.kube/config"
        chmod 600 "$HOME/.kube/config"
        echo "‚úÖ kubeconfig loaded"

    # ==========================================================
    # üß© STEP 3: Staging deployment
    # Switches to the staging cluster context, ensures the
    # namespace exists, applies manifests (or Helm chart),
    # and waits for successful rollout of the service.
    # ==========================================================
    - name: üß© Staging deployment
      shell: bash
      run: |
        set -euo pipefail
        FULL_IMAGE="docker.io/${{ inputs.image_space }}/${{ inputs.image_repo }}:${{ inputs.image_ver }}"
        echo "üöÄ Deploying '${FULL_IMAGE}' to staging context '${{ inputs.staging_cluster }}' namespace '${{ inputs.staging_namespace }}'"
        kubectl config use-context "${{ inputs.staging_cluster }}"
        kubectl get namespace "${{ inputs.staging_namespace }}" >/dev/null 2>&1 || kubectl create namespace "${{ inputs.staging_namespace }}"
        kubectl apply -f "${{ inputs.manifests }}" -n "${{ inputs.staging_namespace }}"
        kubectl rollout status deploy/${{ inputs.image_repo }} -n "${{ inputs.staging_namespace }}" --timeout=300s
        echo "‚úÖ Staging rollout finished"

    # ==========================================================
    # üß™ STEP 4: Health & Smoke Tests
    # Executes a lightweight smoke test inside the staging
    # namespace using curl to validate that the service
    # responses correctly at the configured health endpoint.
    # ==========================================================
    - name: üß™ Health & Smoke Tests
      shell: bash
      run: |
        set -eo pipefail
        echo "Running health check for image=${{ inputs.image_repo }} endpoint=${{ inputs.health_endpoint }}"
        SERVICE_HOST="${{ inputs.image_repo }}"
        SERVICE_PORT=${{ env.SERVICE_PORT:-8080 }}
        ENDPOINT="${{ inputs.health_endpoint }}"
        kubectl run --rm -i "${{ inputs.image_repo }}-smoke" --image=curlimages/curl -n "${{ inputs.staging_namespace }}" --restart=Never --command -- sh -c \
          "curl -sf http://${SERVICE_HOST}:$SERVICE_PORT$ENDPOINT || exit 1"
        echo "‚úÖ Staging health OK"
      env:
        SERVICE_PORT: 8080

    # ==========================================================
    # ‚è∏Ô∏è STEP 5: Manual Approval (Production)
    # Creates a temporary GitHub Issue and waits for an
    # authorized approver to manually approve before
    # proceeding to production rollout. Enforces timeout.
    # ==========================================================
    - name: ‚è∏Ô∏è Manual Approval (Production)
      uses: trstringer/manual-approval@v1
      with:
        secret: ${{ github.token }}
        approvers: ${{ inputs.approvers }}
        minimum-approvals: 1
        issue-title: Approve Production Rollout for ${{ inputs.image_repo }}
        issue-body: |
          ‚úÖ Staging passed for ${{ inputs.image_repo }}
          üîñ Image: ${{ inputs.image_repo }}:${{ inputs.image_ver }}
          Please approve deployment to Production.
        timeout-minutes: ${{ inputs.approval_timeout_minutes }}

    # ==========================================================
    # üß© STEP 6: Production rollout
    # Switches to the production cluster context, ensures
    # namespace existence, applies manifests, and monitors
    # rollout until completion. Timeout set to 10 minutes.
    # ==========================================================
    - name: üß© Production rollout
      shell: bash
      run: |
        set -euo pipefail
        FULL_IMAGE="docker.io/${{ inputs.image_space }}/${{ inputs.image_repo }}:${{ inputs.image_ver }}"
        echo "üöÄ Rolling out '${FULL_IMAGE}' to production context '${{ inputs.prod_cluster }}' namespace '${{ inputs.prod_namespace }}'"
        kubectl config use-context "${{ inputs.prod_cluster }}"
        kubectl get namespace "${{ inputs.prod_namespace }}" >/dev/null 2>&1 || kubectl create namespace "${{ inputs.prod_namespace }}"
        kubectl apply -f "${{ inputs.manifests }}" -n "${{ inputs.prod_namespace }}"
        kubectl rollout status deploy/${{ inputs.image_repo }} -n "${{ inputs.prod_namespace }}" --timeout=600s
        echo "‚úÖ Production rollout completed"

    # ==========================================================
    # üìä STEP 7: Observability & Alerts (safe)
    # Collects recent deployment logs and checks for error
    # patterns. Pushes metrics to Prometheus, creates
    # Grafana annotations, and sends Slack alerts ‚Äî all
    # optional and safely skipped if configs are missing.
    # ==========================================================
    - name: üìä Observability & Alerts (safe)
      shell: bash
      env:
        PROM_PUSH_URL: ${{ inputs.prom }}
        SLACK_WEBHOOK_URL: ${{ inputs.slack }}
        GRAFANA_URL: ${{ inputs.grafana }}
        GRAFANA_API_KEY: ${{ inputs.grafana_key }}
      run: |
        set -euo pipefail
        echo "Collecting recent logs for ${{ inputs.image_repo }}"
        kubectl logs -l app=${{ inputs.image_repo }} -n "${{ inputs.prod_namespace }}" --tail=300 > deploy_logs.txt || true
        if grep -qE "ERROR|Exception|Fail|panic" deploy_logs.txt; then
          echo "‚ö†Ô∏è Errors detected in deployment logs"
          DEPLOY_STATUS=0
          ALERT_COLOR="#ff0000"
          ALERT_MSG="üö® *Deployment FAILED!* image *${{ inputs.image_repo }}* (version *${{ inputs.image_ver }}*) encountered errors."
        else
          echo "‚úÖ Logs look clean"
          DEPLOY_STATUS=1
          ALERT_COLOR="#36a64f"
          ALERT_MSG="‚úÖ *Deployment successful!* image *${{ inputs.image_repo }}* (version *${{ inputs.image_ver }}*) is healthy."
        fi
        if [ -n "${PROM_PUSH_URL:-}" ]; then
          echo "üìà Pushing deployment metrics to ${PROM_PUSH_URL}"
          cat <<EOF | curl --silent --show-error --data-binary @- "${PROM_PUSH_URL}/metrics/job/deployment/image/${{ inputs.image_repo }}"
        deployment_status ${DEPLOY_STATUS}
        deployment_timestamp $(date +%s)
        deployment_version_info{image="${{ inputs.image_repo }}",version="${{ inputs.image_ver }}"} 1
        EOF
        else
          echo "‚ö†Ô∏è PROM_PUSH_URL not configured - skipping metrics push"
        fi
        if [ -n "${GRAFANA_URL:-}" ] && [ -n "${GRAFANA_API_KEY:-}" ]; then
          echo "üß† Creating Grafana annotation"
          curl -s -X POST "${GRAFANA_URL}/api/annotations" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${GRAFANA_API_KEY}" \
            -d "$(jq -n --arg text "Deployment of ${{ inputs.image_repo }}:${{ inputs.image_ver }}" --arg tags "deployment,${{ inputs.image_repo }}" '{text: $text, tags: ($tags | split(","))}')" || echo "‚ö†Ô∏è Failed to push Grafana annotation"
        else
          echo "‚ö†Ô∏è Grafana not configured - skipping annotation"
        fi
        if [ -n "${SLACK_WEBHOOK_URL:-}" ]; then
          echo "üí¨ Sending Slack notification"
          curl -s -X POST "${SLACK_WEBHOOK_URL}" \
            -H "Content-Type: application/json" \
            -d "$(jq -n --arg text "${ALERT_MSG}" --arg color "${ALERT_COLOR}" '{attachments: [{color: $color, text: $text}]}')" || echo "‚ö†Ô∏è Failed to send Slack alert"
        else
          echo "‚ö†Ô∏è Slack webhook not configured - skipping alert"
        fi

    # ==========================================================
    # üìã STEP 8: Summary & Reporting
    # Generates a deployment summary file (report.txt)
    # containing image, context, and timestamp details.
    # ==========================================================
    - name: üìã Summary & Reporting
      shell: bash
      run: |
        set -euo pipefail
        echo "Generating deployment summary"
        cat > report.txt <<EOF
        Image: ${{ inputs.image_repo }}:${{ inputs.image_ver }}
        Staging: context=${{ inputs.staging_cluster }} ns=${{ inputs.staging_namespace }}
        Production: context=${{ inputs.prod_cluster }} ns=${{ inputs.prod_namespace }}
        Timestamp: $(date -u)
        EOF
        echo "Upload artifact"

    # ==========================================================
    # üì¶ STEP 9: Artifact upload
    # Uploads the generated deployment summary as a
    # downloadable artifact for post-deployment tracking.
    # ==========================================================
    - name: üì¶ Artifact upload
      uses: actions/upload-artifact@v4
      with:
        name: cd-report-${{ inputs.image_repo }}
        path: report.txt
